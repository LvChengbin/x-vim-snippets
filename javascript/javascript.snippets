# define variables

snippet "~co?n?s?t?" "const x = 1" r
const ${1} = ${2};
endsnippet

snippet ~c` "const x = ``"
const ${1} = `${2}`;
endsnippet

snippet "~le?t?" "let x = 1" r
let ${1} = ${2};
endsnippet

snippet ~l` "let x = ``"
let ${1} = `${2}`;
endsnippet

# class
snippet ~cls "class C {}"
class ${1}{
	${0:${VISUAL}}
}
endsnippet

# class with constructor
snippet ~clsc "class C { constructor() {} }"
class ${1}{
	constructor( ${2:options = \{\}} ) {
		${0:${VISUAL}}
	}
}
endsnippet

# class extends from another object
snippet ~clse "class C extends S {}"
class ${1}extends ${2:Base} {
	${0:${VISUAL}}
}
endsnippet

# class extends from another object with a constructor
snippet ~clsec "class C extends E { constructor( o ) { super( o ) } }"
class ${1}extends ${2:Base} {
	constructor( ${3:options = \{\}} ) {
		super( ${4:options} );
		${0:${VISUAL}}
	}
}
endsnippet

# for
snippet ~for "for( let i = 0, l = x.length; i < l; i += 1 ) { const item = x[ i ]; }"
for( let ${1:i} = 0, ${2:l} = ${3:list}.length; $1 < $2; $1 += 1 ) {
	const ${4:item} = $3[ $1 ];
	${0:${VISUAL}}
}
endsnippet

# for...of
snippet ~forof "for( const item of list ) {}"
for( ${1:const} ${2:item} of ${3:list} ) {
	${0:${VISUAL}}
}
endsnippet

# for...in
snippet ~forin "for( let prop in obj ) { const item = obj[ prop ]; }"
for( ${1:const} ${2:prop} in ${3:obj} ) {
	const ${4:item} = $3[ $2 ];
	${0:${VISUAL}}
}
endsnippet
# functions

# arrow function
snippet ~f "( arg1, arg2, ... ) => {}"
(${1}) => {
	${0:${VISUAL}}
}
endsnippet

# arrow function end with a )
snippet ~f) "( arg1, arg2, ... ) => {} );"
(${1}) => {
	${0:${VISUAL}}
} );
endsnippet

# arrow function end with a ;
snippet ~f; "( arg1, arg2, ... ) => {} );"
(${1}) => {
	${0:${VISUAL}}
};
endsnippet

snippet ~fun "function( arg1, arg2, ... ) {}"
function(${1}) {
	${0:${VISUAL}}
}
endsnippet

snippet "~nfun?c?t?i?o?n?" "function fn( arg1, arg2, ... ) {}" r
function ${1}(${2}) {
	${0:${VISUAL}}
}
endsnippet

# async arrow function
snippet ~af "async ( arg1, arg2, ... ) => {}"
async (${1}) => {
	${0:${VISUAL}}
}
endsnippet

# async method
snippet ~am "async func() {}"
async ${1}(${2}) {
	${0:${VISUAL}}
}
endsnippet

# static method
snippet ~sm "static func() {}"
static ${1}(${2}) {
	${0:${VISUAL}}
}
endsnippet

# async anonymous function
snippet ~afun "async function( arg1, arg2, ... ) {}"
async function(${1}) {
	${0:${VISUAL}}
}
endsnippet

# async named function
snippet ~anfun "async function fn( arg1, arg2, ... ) {}"
async function ${1}(${2}) {
	${0:${VISUAL}}
}
endsnippet

# arrow function with only one argument
snippet ~f? "x => {}"
${1} => {
	${0:${VISUAL}}
}
endsnippet

# arrow function with only one argument end with a )
snippet ~f?) "x => {} );"
${1} => {
	${0:${VISUAL}}
} );
endsnippet

# arrow function with only one argument end with a ;
snippet ~f?; "x => {} );"
${1} => {
	${0:${VISUAL}}
};
endsnippet

# async arrow function with only one argument
snippet ~af? "async x => {}"
async ${1} => {
	${0:${VISUAL}}
}
endsnippet

# an iife
snippet ~iife "( () => {} )()"
( () => {
	${0:${VISUAL}}
} )();
endsnippet

# throw

# throw an Error instance
snippet ~tr "throw new Error( error message )"
throw new Error( '${1:error message}' );
endsnippet

# throw an TypeError instance
snippet ~ttr "throw new TypeError( error message )"
throw new TypeError( '${1:error message}' );
endsnippet

# try
snippet ~try "try { ... } catch( e ) { ... }"
try {
	${0:${VISUAL}}
} catch( ${1:e} ) {
	${2:/* handle error*/}
}
endsnippet

# try catch statement with finally
snippet ~tryf "try { ... } catch( e ) { ... } finally { ... }"
try {
	${3:${VISUAL}}
} catch( ${1:e} ) {
	${2:/* handle error*/}
} finally {
	${0:${VISUAL}}
}
endsnippet

# switch
snippet ~switch
switch( ${1} ) {
	case '${2}' :${3}
		${5}
		break;
	${3/\{/\}/}
	${0}
	default :
		${4}
}
endsnippet

snippet ~case "case x : ... break;"
case '${1}' :
	${0:${VISUAL}}
	${2:break;}
endsnippet

# case with braces
snippet ~case{ "case x : { ...break; }"
case '${1}' : {
	${$0:${VISUAL}}
	${2:break;}
}
endsnippet

#symbol
snippet "~symbo?l?" "const A_B_C = Symbol( 'a#b#c' )" r
const ${1} = Symbol( '${1/([A-Za-z])|(_)/(?1:\l$0)(?2:#)/g}' );
endsnippet

#symbol.for
snippet "~symbo?l?.for" "const A_B_C = Symbol.for( 'a#b#c' )" r
const ${1} = Symbol.for( '${1/([A-Za-z])|(_)/(?1:\l$0)(?2:#)/g}' );
endsnippet

# if

# if
snippet ~if "if( conditions ) {}"
if( ${1} ) {
	${0:${VISUAL}}
}
endsnippet

# if...else
snippet ~ifel "if ... else ..."
if( ${1} ) {
	${2}
} else {
	${0:${VISUAL}}
}
endsnippet

# if...elseif...
snippet ~ifelif "if ... else if ..."
if( ${1} ) {
	${2}
} else if( ${3} ) {
	${0:${VISUAL}}
}
endsnippet

# if( ... ) break
snippet ~ifb "if( conditions ) break;"
if( ${0} ) break;
${0:${VISUAL}}
endsnippet

# if( ... ) continue
snippet ~ifc "if( conditions ) continue;"
if( ${1} ) continue;
${0:${VISUAL}}
endsnippet

# if ( ...) return
snippet ~ifr "if( conditions ) return;"
if( ${1} ) return${2:${VISUAL}};
${0:${VISUAL}}
endsnippet

# assignment

snippet ~|| "x || ();"
${1} || ( $1 = ${2} );
endsnippet

# json

# JSON.parse
snippet ~jp "JSON.parse( object )"
JSON.parse( ${0} );
endsnippet

# JSON.stringify
snippet ~jstr "JSON.stringify( json )"
JSON.stringify( ${0} );
endsnippet

# dom selector

# document.querySelector( selector )
snippet ~$ "document.querySelector( selectors )"
${0:document}.querySelector( '${1:selector}' );
endsnippet

# document.querySelectorAll( selector )
snippet ~$$ "document.querySelectorAll( selectors )"
${0:document}.querySelectorAll( '${1:selector}' );
endsnippet

# document.getElementById( id )
snippet ~$#
document.getElementById( '${0:id}' );
endsnippet

# console
snippet ~csl "console.log( ...args )"
console.log( ${0:${VISUAL}} );
endsnippet

snippet ~csw "console.warn( ...args )"
console.warn( ${0:${VISUAL}} );
endsnippet

snippet ~csd "console.debug( ...args )"
console.debug( ${0:${VISUAL}} );
endsnippet

snippet ~cse "console.error( ...args )"
console.error( ${0:${VISUAL}} );
endsnippet

snippet ~csi "console.info( ...args )"
console.info( ${0:${VISUAL}} );
endsnippet

# use strict
snippet ~us "'use strict'"
'use strict';
${0:{VISUAL}}
endsnippet

# modules

# import es6 module
snippet ~im "import X from 'path';"
import ${1} from '${0}';
endsnippet

snippet ~imx "import {a,b} from 'path';"
import { ${1} } from '${0}';
endsnippet

# import packages from @lvchengbin
snippet ~imlcb "import x from '@lvchengbin/x';"
import ${1} from '@lvchengbin/${1/\w/\l$0/g}';
endsnippet

# import packages from current dir
snippet ~imrel "import x from './x';"
import ${1} from './${1/\w/\l$0/g}';
endsnippet

# import file from @lvchengbin/is
snippet ~imlcbis "import isXX from '@lvchengbin/is/src/xx';"
import is${1} from '@lvchengbin/is/src/${1/\w/\l$0/g}';
endsnippet

snippet ~exd "export default x;"
export default ${0};
endsnippet

snippet ~mexi "module.exports.x = {};"
module.exports.${1} = ${0:${VISUAL}}
endsnippet

snippet ~mex "module.exports.x = {};"
module.exports = ${0:${VISUAL}}
endsnippet

#require

# require at the beginning of the line
snippet "~re?q?" "const x = require( 'path' );" rb
const ${1} = require( '${2:$1}' );
endsnippet

snippet ~rrel "const x = require( './x' );"
const ${1} = require( './${1/\w/\l$0/g}${0:${VISUAL}}' );
endsnippet

snippet ~rlcb "const x = require( '@lvchengbin/x' );"
const ${1} = require( '@lvchengbin/${1/\w/\l$0/g}' );
endsnippet

# Promise

snippet ~then ".then( () => {} );" i
.then( ${1} => { ${0:${VISUAL}} } );

# .then().catch()
snippet ~thenc ".then( () => {} ).catch( e => console.log( e ) );" i
.then( ${1} => {
	${0:${VISUAL}}
} ).catch( e => {
	console.log( e );
} );
endsnippet

# settimeout
snippet ~sto "setTimeout(() => {}, delay);"
setTimeout( () => {
	${0:${VISUAL}}
}, ${1:0})
endsnippet

# call
snippet ~call "func.call( this, ...args )"
${1}.call( ${2:this}, ${3:...args} );
endsnippet

# multiple lines comment
snippet ~cmt "/** */"
/**
 * ${0:${VISUAL}}
 */
endsnippet

# regexp

# all the characters are numeric
snippet ~reg.n "/^\d+$/" i
/^\d+$/
endsnippet

# all the characters are numeric
snippet ~if.reg.n "/^\d+$/" i
if( /^\d+$/.test( ${1} ) ) {
	${0:${VISUAL}}
}
endsnippet

# to test a string is filled all by numeric
snippet ~reg.n.t "/^\d+$/" i
/^\d+$/.test( ${1} )
endsnippet

# lowercase string
snippet ~reg.lc "/^[a-z]+$/"
/^[a-z]+$/
endsnippet

# test lowercase string
snippet ~reg.lc.t "/^[a-z]+$/"
/^[a-z]+$/.t( ${1} )
endsnippet

# uppercase string
snippet ~reg.lu "/^[A-Z]+$/"
/^[A-Z]+$/
endsnippet

# test uppercase string
snippet ~reg.lu.t "/^[A-Z]+$/"
/^[A-Z]+$/.t( ${1} )
endsnippet

snippet fims.service
import { Injectable } from '@ynn/injection';
import { IdallocService, FimsGeneralIndex, PaginateResult } from '@fims/common';
import { ${1}, ${1/\w+/\u$0/g}Creation, ${1/\w+/\u$0/g}Update } from '../interfaces';
import { ${1/\w+/\u$0/g}Model } from '../models';
import { ${1/\w+/\u$0/g}SearchService } from './${1/\w+/\l$0/g}-search.service';

@Injectable()
export class ${1/\w+/\u$0/g}Service {
	constructor(
		private model: ${1/\w+/\u$0/g}Model,
		private idalloc: IdallocService,
		private ${1/\w+/\l$0/g}SearchService: ${1/\w+/\u$0/g}SearchService
	) {}
	${0:${VISUAL}}
	async searchIndex( data: ${1/\w+/\u$0/g} | null ): Promise<void> {
		if( data ) await this.${1/\w+/\u$0/g}SearchService.create( data );
	}

	async get( condition: FimsGeneralIndex ): Promsie<${1/\w+/\u$0/g} | null> {
		return this.model.get( condition );
	}

	async create( params: ${1/\w+/\u$0/g}Creation ): Promise<string> {
		const id = await this.idalloc.id();
		const data = await this.model.insert( { ...params, id } );
		await this.searchIndex( data );
		return id;
	}

	async update( condition: FimsGeneralIndex, data: ${1/\w+/\u$0/g}Update ): Promise<${1/\w+/\u$0/g} | null> {
		const ${1/\w+/\l$0/g} = await this.model.update( condition, data );
		await this.searchIndex( ${1/\w+/\l$0/g} );
		return tag;
	}

	async list( appid: string ): Promise<PaginateResult<${1/\w+/\u$0/g}>> {
		return this.model.paginate( { appid }, { count : true } );
	}

	async delete( condition: FimsGeneralIndex ): Promise<${1/\w+/\u$0/g} | null> {
		return this.model.delete( condition );
	}
}
endsnippet

snippet fims.controller
import { Controller, Put, Post, Get, Delete, Body, Param, NotFoundException } from '@ynn/http';
import { Appid, PaginateResult } from '@fims/common';
import { ${1} } from '../interfaces';
import { ${1/\w+/\u$0/g}CreationData, ${1/\w+/\u$0/g}UpdateData } from '../dataclass';
import { ${1/\w+/\u$0/g}Service } from '../services';

@Controller( '/:appid/${1/\w+/\l$0/g}' )
export class ${1/\w+/\u$0/g}Controller {
    constructor( private service: ${1/\w+/\u$0/g}Service ) {}

    @Post()
    async create( @Appid() @Body() data: ${1/\w+/\u$0/g}CreationData ): Promise<{ id: string }> {
        const id = await this.service.create( data );
        return { id };
    }

    @Get()
    async list( @Appid() appid: string ): Promise<PaginateResult<${1/\w+/\u$0/g}>> {
        return this.service.list( appid );
    }

    @Get( ':id' )
    async get( @Appid() appid: string, @Param( 'id' ) id: string ): Promise<${1/\w+/\u$0/g}> {
        const ${1/\w+/\l$0/g} = await this.service.get( { appid, id } );
        if( !${1/\w+/\l$0/g} ) throw new NotFoundException( \`${1/\w+/\l$0/g} ${id} not found\` );
        return ${1/\w+/\l$0/g};
    }

    @Put( ':id' )
    async update(
        @Appid() appid: string,
        @Param( 'id' ) id: string,
        @Appid() @Param() @Body() data: ${1/\w+/\u$0/g}UpdateData
    ): Promise<void> {
        const ${1/\w+/\l$0/g} = await this.service.update( { appid, id }, data );
        if( !${1/\w+/\l$0/g} ) throw new NotFoundException( \`${1/\w+/\l$0/g} ${id} not found\` );
    }

    @Delete( ':id' )
    async delete( @Appid() appid: string, @Param( 'id' ) id: string ): Promise<void> {
        const ${1/\w+/\l$0/g} = await this.service.delete( { appid, id } );
        if( !${1/\w+/\l$0/g} ) throw new NotFoundException( \`${1/\w+/\l$0/g} ${id} not found\` );
    }
}
endsnippet

snippet fims.model
import { Injectable } from '@ynn/injection';
import { MongoService, MongoModel } from '@fims/common';
import { ${1} } from '../interfaces';

@Injectable()
export class ${1/\w+/\u$0/g}Model extends MongoModel<${1/\w+/\u$0/g}> {
	static schema = MongoService.Schema( {
		id : { type : String, unique : true, required : true },
		${0:${VISUAL}}
	} );

	static collection = 'fims.${1/\w+/\l$0/g}';
	static model = '${1/\w+/\u$0/g}';

	constructor( service: MongoService ) {
		super( service );
	}
}
endsnippet

snippet fims.searchmodel
import { Client, estypes } from '@elastic/elasticsearch';
import { Injectable } from '@ynn/injection';
import { ElasticSearchService } from '@fims/common';
import { ${1} } from '../interfaces';

export const ${1/\w+/\l$0/g}SearchIndexMapping = {
	properties : {
		id : { type : 'keyword' },
		appid : { type : 'keyword' }
	}
};

@Injectable()
export class ${1/\w+/\u$0/g}SearchModel {
	client: Client;
	index = 'fims-${1/\w+/\l$0/g}';

	constructor( private elasticsearch: ElasticSearchService ) {
		this.client = elasticsearch.client;
		this.init();
	}

	async init(): Promise<void> {
		const { index, client } = this;

		if( !await client.indices.exists( { index } ) ) {
			await client.indices.create( {
				index,
				// eslint-disable-next-line @typescript-eslint/no-explicit-any
				mappings : ${1/\w+/\l$0/g}SearchIndexMapping as any
			} );
		}
	}

	async create( ${1/\w+/\l$0/g}: ${1/\w+/\u$0/g} ): Promise<void> {
		await this.client.index( {
			index : this.index,
			id : ${1/\w+/\l$0/g}.id,
			document : ${1/\w+/\l$0/g}
		} );
	}

	async search( body?: object ): Promise<estypes.SearchHitsMetadata<${1/\w+/\u$0/g}>> {
		const options = body
			? { index : this.index, ...body }
			: { index : this.index };

		const result = await this.client.search<${1/\w+/\u$0/g}>( options );
		return result.hits;
	}
}
endsnippet

snippet fims.client.controller
import { Controller, Post, Get, Put, Delete } from '@ynn/http-client';
import { PaginateResult } from '@fims/common/interfaces';
import { ${1} } from '../../interfaces';

export interface ${1/\w+/\u$0/g}Methods {
    create: { id: string };
    list: PaginateResult<${1/\w+/\u$0/g}>;
    get: ${1/\w+/\u$0/g};
    update: void;
    delete: void;
}

@Controller( ':appid/${1/\w+/\l$0/g}' )
export class ${1/\w+/\u$0/g}Controller {
    @Post()
    create(): void {}

    @Get()
    list(): void {}

    @Get( ':id' )
    get(): void {}

    @Put( ':id' )
    update(): void {}
}
endsnippet

snippet fims.recoil.atom
import { atomFamily, selectorFamily } from 'recoil';
import { ${1} } from '@fims/service/interfaces';
import { fims } from '@/admin/clients';

const default${1/\w+/\u$0/g} = {
};

export const articleState = atomFamily<${1/\w+/\u$0/g}>( {
	key : 'fims/${1/\w+/\l$0/g}',
	default : selectorFamily( {
		key : '#fims/${1/\w+/\l$0/g}',
		get : id => async (): Promise<${1/\w+/\u$0/g} | null> => {
			if( !id ) return default${1/\w+/\u$0/g};
			const { body } = await fims.${1/\w+/\l$0/g}.get( { id } );
			return body;
		}
	} )
} );
endsnippet

snippet fims.recoil.list
import { selectorFamily } from 'recoil';
import { PaginateResult } from '@fims/common';
import { ${1} } from '@fims/sservice/interfaces';
import { fims } from '@/admin/clients';

export const ${1/\w+/\l$0/g}ListState = selectorFamily<PaginateResult<${1/\w+/\u$0/g}>>( {
	key : 'fims/${1/\w+/\l$0/g}/list',
	get( options ) {
		return async () => {
			const { body } = await fims.${1/\w+/\l$0/g}.list( options );
			return body;
		};
	}
} );
endsnippet

snippet fims.recoil.search
import { selectorFamily } from 'recoil';
import { PaginateResult } from '@fims/common';
import { ${1} } from '@fims/sservice/interfaces';
import { fims } from '@/admin/clients';
import { ${1/\w+/\l$0/g}ListState } from './${1/\w+/\l$0/g}-list.selector';

export const ${1/\w+/\l$0/g}SearchState = selectorFamily<PaginateResult<${1/\w+/\u$0/g}>>( {
	key : 'fims/${1/\w+/\l$0/g}/search',
	get( options: ${1/\w+/\u$0/g}SearchOptions ) {
		return async ( { get } ): Promise<PaginateResult<${1/\w+/\u$0/g}>> => {

			if( !options.query ) {
				return get( ${1/\w+/\l$0/g}ListState( options ) );
			}

			const { body } = await fims.${1/\w+/\l$0/g}.search( options );
			return body;
		};
	}
} );
endsnippet

snippet fims.hook.search
import { useEffect } from 'react';
import { useRecoilValue, useRecoilCallback, useRecoilRefresher_UNSTABLE as useRecoilRefresher } from 'recoil';
import { ${1}State, ${1/\w+/\l$0/g}SearchState } from '@/admin/recoil/${1/\w+/\l$0/g}';

export function use${1/\w+/\u$0/g}Search( options ) {
    const ${1/\w+/\l$0/g}s = useRecoilValue( ${1/\w+/\l$0/g}SearchState( options ) );
    const save = useRecoilCallback( ( { set } ) => ( id, data ) => {
        set( ${1/\w+/\l$0/g}State( id ), data );
    } );

    useEffect( () => {
        ${1/\w+/\l$0/g}s?.list.forEach( item => { save( item.id, item ) } );
    }, [ ${1/\w+/\l$0/g}s ] );

    const refresh = useRecoilRefresher( ${1/\w+/\l$0/g}SearchState( options ) );
    return { ${1/\w+/\l$0/g}s, refresh };
}
endsnippet

snippet fims.hook.refreshdata
import { useRecoilRefresher_UNSTABLE as useRecoilRefresher } from 'recoil';
import { ${1}State } from '@/admin/recoil/${1/\w+/\l$0/g}';

export function useRefresh${1/\w+/\u$0/g}( id?: string | undefined ) {
    return useRecoilRefresher( ${1/\w+/\l$0/g}State( id ) );
}
endsnippet

snippet fims.hook.refreshsearch
import { useRecoilRefresher_UNSTABLE as useRecoilRefresher } from 'recoil';
import { ${1}SearchState } from '@/admin/recoil/${1/\w+/\l$0/g}';
import { ${1/\w+/\u$0/g}SearchOptions } from '@fims/service/interfaces';

export function useRefresh${1/\w+/\u$0/g}Search( options ) {
    return useRecoilRefresher( ${1/\w+/\l$0/g}SearchState( options ) );
}
endsnippet

snippet fims.hook.data
import { useRecoilValue, useRecoilRefresher_UNSTABLE as useRecoilRefresher } from 'recoil';
import { ${1}State } from '@/admin/recoil/${1/\w+/\l$0/g}';

export function use${1/\w+/\u$0/g}( id?: string | undefined ) {
	const ${1/\w+/\l$0/g} = useRecoilValue( ${1/\w+/\l$0/g}State( id ) );
	const refresh = useRecoilRefresher( ${1/\w+/\l$0/g}State( id ) );

	return { ${1/\w+/\l$0/g}, refresh };
}
endsnippet

snippet fims.hook.freshdata
import { useEffect } from 'react';
import { use${1} } from './use${1/\w+/\u$0/g}';

export function useFresh${1/\w+/\u$0/g}( id?: string | undefined ) {
	const { refresh, ${1/\w+/\l$0/g} } = use${1/\w+/\u$0/g}( id );
	useEffect( () => { refresh() }, [] );
	return { refresh, ${1/\w+/\l$0/g} };
}
endsnippet

snippet fims.hook.freshsearch
import { useEffect } from 'react';
import { use${1}Search } from './use${1/\w+/\u$0/g}Search';

export function useFresh${1/\w+/\u$0/g}Search( options ) {
	const { refresh, ${1/\w+/\l$0/g}s } = use${1/\w+/\u$0/g}Search( options );
	useEffect( () => { refresh() }, [] );
	return { refresh, ${1/\w+/\l$0/g}s };
}
endsnippet

snippet fims.hook.update
import { useRecoilCallback } from 'recoil';
import { useAsyncFn } from 'react-use';
import { ${1/\w+/\u$0/g}Update } from '@fims/service/interfaces';
import { fims } from '@/admin/clients';
import { ${1/\w+/\l$0/g}State } from '@/admin/recoil/${1/\w+/\l$0/g}';

export function useUpdate${1/\w+/\u$0/g}( id?: string | undefined ) {
	const save = useRecoilCallback( ( { set } ) => ( id, data ) => {
		set( ${1/\w+/\l$0/g}State( id ), ( ${1/\w+/\l$0/g} ) => {
			return { ...${1/\w+/\l$0/g}, ...data };
		} );
	} );

	const [ update${1/\w+/\u$0/g}State, update${1/\w+/\u$0/g} ] = useAsyncFn(
		async ( data: ${1/\w+/\u$0/g}Update ): Promise<void> => {
			save( data.id ?? id, data );
			await fims.${1/\w+/\l$0/g}.update( { id, ...data } );
		}
	);

	return { update${1/\w+/\u$0/g}State, update${1/\w+/\u$0/g} };
}
endsnippet
